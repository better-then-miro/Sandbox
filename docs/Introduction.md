# Знакомство с веб разработкой  
## trivia
Теперь можем начать разбираться с тем, что и как устроено. Вы наверное уже поняли, что  
Веб приложение делится на backend и frontend. Каждая отвечает за свой кусок.

Backend по факту большое приложение на сервере, которое с помощью абстракций операционной  
системы принимает запросы и возвращает на них ответы. Если максимально упростить, то это  
все, зачем эта сторона нужна. За Backend у нас будет отвечает питон и его фреймворк Flask.  
Кстати не парьтесь за слово фреймворк. По факту это просто асбтракция, которая позволяет  
работать с каким то ресурсом. В нашем случае абстракция над сокетами и протоколами  
передачи данных.

Теперь перейдем к более интересной(ха-ха) для вас части - Frontend. На самом деле в него  
входит огромный ворох всяких разных вещей.   

Перво-наперво html документ. Это то, что вы видите когда вам возвращается ответ на  
запрос (про сами   запросы чуть позже). К этому документу могут(и, по современной   
практике должны) прилагаться css   стили. По факту, html просто предоставляет вам  
набор всяких штук, типа заголовков, кнопок, тексовых  полей, полей для ввода и тд,  
плюс правила по которым вы можете эти штуки разместить. Каждому из них можно задавать  
уникальные идентификаторы классов (аттрибут class), внешний вид которых можно менять  
с помощью css стиля. Это то, что касается дИзАйНеРсКоЙ стороны фронта.  

Теперь кое-что поинтереснее - логика. За нее отвечает великий и могучий джаваскрипт.  
Вообще эта штука, которая буквально вшивается в html документ. Его не надо импортировать  
или что-то вроде того. Вы увидите ниже как его вшивать. Сейчас поговорим о том, что он  
может. В первую очередь, он имеет полный доступ к html документу и css стилям. То есть  
скрипт написанный на js может менять внешний облик страницы, любым желаемым образом.  


Второе, за что он отвечает это общение с сервером. Как уже было сказанно оно происходит  
через запросы. На практике есть два типа запросов: **GET** и **POST**. Первый тип - самый простой  
Его выполняет любой браузер, когда вы вводите адрес в поисковой странице. Например,   
вы обращаетесь к https://vk.com/im . Когда вы вводите этот адрес, браузер селектит протокол   
обращения (https), с помощью днс резолвера определяет ip адрес сервера (vk.com), и потом  
отдает **GET** запрос этому серверу. Сервер видит, что обращение произошло по /im , то есть  
по страничке ваших диалогов, что то там у себя вычисляет и возвращает вам страничку.  
**GET** достаточно громоздкий и неудобный. Например, что, если вы отдаете запрос на поиск на  
этой страничке диалогов по какому-то ключевому слову или имени? Вам нужно сообщить серверу,  
что запрос вообще-то специфицированный. То есть нам нужно передать набор аргументов.  
**GET** умеет в их передачу, но это выглядит ужасно. Аргументы передаются через знак ?, что то  
вроде vk.com/im?search=pidor. Сервер получит аргумент search, который будет равняться  
понятно чему. Если вы когда нибудь пользовались амазоном, алибабой или на худой конец  
алиэкспрессом, то видели, что ссылки у них похожи на какой-то адский ворох непонятно чего.  
Помимо эстетики, это вроде как угроза безопасности и вообще бе. Поэтому есть **POST** запросы.  
Они отправляются незаметно для пользователя и очень часто выглядят как набор пар вида  
**переменная : значение**. Есть даже специальный формат для передачи данных, которым   
мы скорее всего и будем пользоваться - json. У **POST** запроса есть всякие обязательные  
параметры вроде хэдера, но про них на этом этапе париться не следует. На этом в целом все  
по теории. Давайте копаться в коде.  


## \_\_init\_\_.py и sandbox.py  

В действительности, всё наше приложение хранится в папке app. Вне её, действительно важен  
только **sandbox.py**. Кстати, если вы в него заглянете, то увидите забавную картину:  
в нем ровно одна строка.  

` from app import socketio `

Если вам по какой-то причине интересно как это работает, ведь app это вроде как папка, но  
мы импортируем её как полноценный питоновский модуль *.py* , то разгадка состоит в том, что  
лежит в папке app. Помимо других папок в ней есть файл **\_\_init\_\_.py**. Оказывается, питон  
умеет интерпретировать любую папку с инитом как модуль и автоматически вызывает инит при её импорте.   
На этом этапе можете глянуть в него, он измазан комментариями, но логическая функция у него  
именно в инициализации приложения.

## routes.py

Теперь поговорим о месте, где будет происходить магия бэкенда. По факту, все самое важное  
лежит в routes.py. Если заглянуть в него, то вы увидите штуки вида 

```
@app.route('/<linkname>', methods = ['GET','POST'])
def <linkname>():
    *code*
```

По факту мы просто определяем поведение нашего сервера при приёме одного из перечисленных  
типов запросов по ссылке <server_name\>.<domen_type\>/<linkname\>. Т.е. для приведенного  
выше пример с vk.com/im, у нас было бы что то вроде 

```
@app.route('/im', methods = ['GET','POST'])
def im():
    if request.method == 'POST':
        *code for post request* 
    else:
        *code for GET request*
```
Кстати справедливости ради, не стоит пихать туда **else** потому что в природе существуют и  
другие типы запросов и это потенциальная уязвимость... Но это все равно болванка, которая  
нигде, кроме наших компов не поднимется :). Строка 

```@app.route('/im', methods = ['GET','POST'])```

И вообще все строки, которые начинаются с **@** это так называемые декораторы. Это  
синтаксический сахар над коллбеками. Т.е. функция под декоратором, будет передана как аргумент  
функции, указанной в декораторе. Вот вам и та самая событийная архитектура. Мы по факту пишем  
хэндлеры для событий фласка, которые позовутся, когда это событие произойдет. Обратите внимание  
на example1. В нем присутствует строка 

```return render_template("index.html", exNumber = "1", user=user, posts = posts )```

Она намекает, что есть какой-то шаблон index.html, его рендерят и возвращают. Пришло время   
поговорить и фронтэнде.   

## Jinja2, Шаблонизация и /templates

Итак, как и было сказано, весь фронтэнд строится вокруг html документов. Собственно их мы  
и хотим возвращать при получении GET запроса. Стандартный путь для хранения html страничек  
это app/templates. Однако, очевидно, что странички не универсальные. Мало того, что нам нужно  
время от времени отображать какие-то спицифичные для пользователя данные, так у нас есть еще и    
элементы страницы, которые не меняются никогда. В фронте их вроде называют шапкой и подвалом  
у вк это вот эта верхняя часть с лого, строкой поиска и прочей ерундой в самом верху страницы.  
Так вот с этой целью была разработана шаблонизация. Попрбуйте открыть base.html.  
Помимо привычного html кода вы увидите:  
условия и проверки переменных  
``` 
{% if exNumber %}
...
{% else %}
...
{% endif %}
```
загадочные блоки   

` {% block content %}{% endblock %} `

Теперь попробуйте открыть index.html . Во первых он начинается с  

`{% extends "base.html" %}`

Которые очевидным образом намекает, что мы расширяем base.html. Далее следуют  

```
{% block content %}
...
{% endblock %}
```

Уже смекаете? Эта штука работает как инклуды в си. Она подставляет в файл, который мы расширяем  
весь текст, который написан в текущем файле на места, где указаны   
{% block content %} {% endblock %} и заполняет переменные тем, что мы передали в функции  
render_template(). Кстати обратите внимание, что jinja2, который делает для нас всю эту магию  
так же умеет в циклы. Кстати двойное наследование вроде как запрещено, но это не точно :)  
Откатитесь назад к месту, где мы звали render_template() и внимательно присмотритесь  
к аргументам функции, если что то не поняли, по идее все должно встать на свои места.  

## javascript и /static

Теперь перейдем к папке, в которую вы будете коммитить чаще всего)00)0  
В /static у нас будут лежать css стили и js скрипты. Обратимся к example3.html и example3.js  
как видите в html мы все еще расширяем base.html. В добавок ко всему, что мы уже посмотрели  
про jinja2 у нас появляется строка 

```
<script type = 'text/javascript' src = "{{ url_for('static', filename = 'example3.js') }}"></script> 
```

как видите наш шаблонизатор умеет сам строить линки для скриптов. Помимо этого нас  
еще интересует строки

```
<div class = 'text_area'><textarea placeholder='Введите сообщение' id = "MessageBox"></textarea></div>
<div class = 'send_button'><input type = 'button' value = 'send' onclick="send_messageExample3();"></div>
```

Как видите у нас есть текстовое поле для ввода пользователя с уникальным id "MessageBox",  
а так же кнопка, которая при нажатии зовет функцию send_messageExample3(). Теперь можем  
переместиться в файл example3.js . В нем эта функция и описана! Не пугайтесь объявления асинхронной  
функции, просто библиотека, которая предоставляет нам возможность отправлять POST запрос на серв  
асинхронная. Можете смотреть на нее как на обычную функцию, потому что мы сразу делаем await,  
то есть ожидаем ответа. Кстати можете зайти в routes.py и увидеть, что у нас там есть функция  
**exmaple3()**, которая проверяет тип запроса и если это GET, то возвращает html страничку,  
а в случае POST, возвращает подтверждение, что json и правда дошел. Кстати еще раз обращу ваше внимание  
на строчку 

`const data = { msg: document.getElementById("MessageBox").value };`

которая извлекает значение из нашего текстового поля по его id . Кстати ф-ця fetch(), которая формирует  
и отправляет запрос, идет в стандартной библиотеке js, так что ничего подчключать не нужно, достаточно   позвать её.


## сторонние javascript библиотеки и SocketIO

Крепитесь! Осталось совсем чуть-чуть. Мы уже поговорили про все основы веб-разработки, которые нам  
потребуются. Теперь стоит обсудить лишь сторонние модули, которые вам скорее всего потребуются для  
жабаскрипта. Обратимся к example2.html . Функционально он полностью повторяет example3, то бишь  
при нажатии кнопки отправляет на сервер json, в который обёрнуты данные из текстового поля.  
Однако делает он это другим способом, напрямую держа соединение с сервером через сокет. Это  
бывает полезно для быстрого и постоянного обмена данными, например для каких-нибудь игр или  
других приложений реального времени (Иртегову привет). В нашем html документе есть две строки   

```
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>
<script type = 'text/javascript' src = "{{ url_for('static', filename = 'example2.js') }}"></script>    
```

Вторая уже должна быть вам знакома. А вот первая... Это просто инклуд библиотеки :) Да, вот так просто!  
Найти их не самая простая задача, но в действительности это все, что нужно сделать, чтобы подключить  
сторонний код. Это же касается и более сложных вещей, например диалектов javascript. Достаточно  
приложить ссылку на этот скрипт и браузер все спокойно подключит. Например, если бы нам захотелось  
подключить jquery, который не совсем чистый javascript, то мы бы просто вставили строку  

```
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
```

и спокойно бы писали на этом диалекте.  

Теперь поговорим о socketio. Он устроен несколько сложнее и целесообразность его использования пока  
что несколько туманна для меня. Но на всякий случай опишу его, мало ли - пригодится.

В отличие от стандартных запросов, для работы напрямую с сокетами нужно напрямую указывать имя функции,  
которая обработает наш запрос на противоположной стороне. Мы инициализируем подключение вызовом socket.io()  

`var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port + namespace);`

Кстати у сокетов появляется дополнительный параметр - **namespace**. Это нужно, чтобы разделить функциональность  
нескольких подключенных сокетов. Обратим внимание на **routes.py** . В нем уже написан хэндлер коннекта  

```
@socketio.on('connect',namespace = '/main')
def test_connect():
    *code*
```

Обратите внимание, что вместо привычного `@app.route(...)` мы используем `@socketio.on(..)`, причем  
первым аргументом, он принимает имя (функции), к которому обращалась другая сторона.  

Взглянем на **send_message()** на стороне клиента. Она вызывает `socket.emit("getMessage", {message:msg})` то бишь пишет в сокет сообщение и явным образом сообщает, что на стороне сервера этот запрос дожна обработать  
функция **"getMessage"**. На серверной стороне имеем  

```
@socketio.on('getMessage',namespace = '/main')
def getMessage(message):
    print(message['message'])
    emit("confirmer",message)
```

Этот хэндлер очевидно распечатает сообщение и переотправит его обратно тем же самым emit'ом.
На стороне клиента же зарегестрирован хэндлер **'confirmer'**, который должен будет что-то   
сделать с полученным ответом. Как видите функциональность повторяется один в один, но  
"объем писанины" вырастает в разы. Возможно на текущем этапе нам это не понадобится,  
но если нам, например, придётся обрабатывать ввод нескольких пользователей, то сокеты  
с некоторой вероятностью окажутся эффективнее.  


## Что дальше?

По большому счёту, это самые основы веб-разработки. Если вы внимательно все прочитали  
и осознали, то я надеюсь, что вы понимаете, как устроен наш проект и что в нем происходит.  

Теперь у вас есть эта песочница. Можете попробовать порисовать всякие штуки и побросать  
разные запросы на сервер. На текущий момент он просто зеркалит все, что вы ему прислали,  
так что вам будет удобно дебажить и вы будете в лайв режиме видеть, все, что видит сервер.  

Попробуйте подключить библиотеки, которыми собираетесь пользоваться и написать на них  
свои болванки для диаграм. Пока не очень осознанные, что-то очень простое, типа базовых  
фигур и скриптов для манипуляций с ними. Так же настоятельно рекомендую создать каждому  
по своей ветке, чтобы у вас была изначальная версия и вы всегда могли откатиться к ней.

